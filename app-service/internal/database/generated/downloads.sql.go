// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: downloads.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateDownload = `-- name: CreateDownload :one
INSERT INTO downloads (
    user_id,
    application_id,
    ip_address,
    success,
    error_message
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, user_id, application_id, timestamp, ip_address, success, error_message
`

type CreateDownloadParams struct {
	UserID        pgtype.UUID `db:"user_id" json:"user_id"`
	ApplicationID pgtype.UUID `db:"application_id" json:"application_id"`
	IpAddress     string      `db:"ip_address" json:"ip_address"`
	Success       bool        `db:"success" json:"success"`
	ErrorMessage  pgtype.Text `db:"error_message" json:"error_message"`
}

func (q *Queries) CreateDownload(ctx context.Context, arg *CreateDownloadParams) (*Download, error) {
	row := q.db.QueryRow(ctx, CreateDownload,
		arg.UserID,
		arg.ApplicationID,
		arg.IpAddress,
		arg.Success,
		arg.ErrorMessage,
	)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ApplicationID,
		&i.Timestamp,
		&i.IpAddress,
		&i.Success,
		&i.ErrorMessage,
	)
	return &i, err
}

const GetDownloadStats = `-- name: GetDownloadStats :one
SELECT 
    COUNT(*) as total_downloads,
    COUNT(CASE WHEN success = true THEN 1 END) as successful_downloads,
    COUNT(CASE WHEN success = false THEN 1 END) as failed_downloads
FROM downloads
WHERE application_id = $1
`

type GetDownloadStatsRow struct {
	TotalDownloads      int64 `db:"total_downloads" json:"total_downloads"`
	SuccessfulDownloads int64 `db:"successful_downloads" json:"successful_downloads"`
	FailedDownloads     int64 `db:"failed_downloads" json:"failed_downloads"`
}

func (q *Queries) GetDownloadStats(ctx context.Context, applicationID pgtype.UUID) (*GetDownloadStatsRow, error) {
	row := q.db.QueryRow(ctx, GetDownloadStats, applicationID)
	var i GetDownloadStatsRow
	err := row.Scan(&i.TotalDownloads, &i.SuccessfulDownloads, &i.FailedDownloads)
	return &i, err
}

const GetDownloadsByApplication = `-- name: GetDownloadsByApplication :many
SELECT id, user_id, application_id, timestamp, ip_address, success, error_message FROM downloads
WHERE application_id = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type GetDownloadsByApplicationParams struct {
	ApplicationID pgtype.UUID `db:"application_id" json:"application_id"`
	Limit         int32       `db:"limit" json:"limit"`
	Offset        int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetDownloadsByApplication(ctx context.Context, arg *GetDownloadsByApplicationParams) ([]*Download, error) {
	rows, err := q.db.Query(ctx, GetDownloadsByApplication, arg.ApplicationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Download{}
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ApplicationID,
			&i.Timestamp,
			&i.IpAddress,
			&i.Success,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDownloadsByUser = `-- name: GetDownloadsByUser :many
SELECT id, user_id, application_id, timestamp, ip_address, success, error_message FROM downloads
WHERE user_id = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type GetDownloadsByUserParams struct {
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetDownloadsByUser(ctx context.Context, arg *GetDownloadsByUserParams) ([]*Download, error) {
	rows, err := q.db.Query(ctx, GetDownloadsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Download{}
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ApplicationID,
			&i.Timestamp,
			&i.IpAddress,
			&i.Success,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
