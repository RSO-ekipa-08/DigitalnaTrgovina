// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: applications.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    name,
    description,
    developer_id,
    category,
    price,
    size,
    min_android_version,
    current_version,
    tags,
    screenshots,
    storage_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING 
    id, name, description, developer_id, category, price, size,
    min_android_version, current_version, tags, screenshots, storage_url,
    rating, downloads, created_at, updated_at
`

type CreateApplicationParams struct {
	Name              string         `db:"name" json:"name"`
	Description       pgtype.Text    `db:"description" json:"description"`
	DeveloperID       pgtype.UUID    `db:"developer_id" json:"developer_id"`
	Category          string         `db:"category" json:"category"`
	Price             pgtype.Numeric `db:"price" json:"price"`
	Size              int64          `db:"size" json:"size"`
	MinAndroidVersion string         `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string         `db:"current_version" json:"current_version"`
	Tags              []string       `db:"tags" json:"tags"`
	Screenshots       []string       `db:"screenshots" json:"screenshots"`
	StorageUrl        string         `db:"storage_url" json:"storage_url"`
}

type CreateApplicationRow struct {
	ID                pgtype.UUID        `db:"id" json:"id"`
	Name              string             `db:"name" json:"name"`
	Description       pgtype.Text        `db:"description" json:"description"`
	DeveloperID       pgtype.UUID        `db:"developer_id" json:"developer_id"`
	Category          string             `db:"category" json:"category"`
	Price             pgtype.Numeric     `db:"price" json:"price"`
	Size              int64              `db:"size" json:"size"`
	MinAndroidVersion string             `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string             `db:"current_version" json:"current_version"`
	Tags              []string           `db:"tags" json:"tags"`
	Screenshots       []string           `db:"screenshots" json:"screenshots"`
	StorageUrl        string             `db:"storage_url" json:"storage_url"`
	Rating            pgtype.Numeric     `db:"rating" json:"rating"`
	Downloads         int32              `db:"downloads" json:"downloads"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg *CreateApplicationParams) (*CreateApplicationRow, error) {
	row := q.db.QueryRow(ctx, CreateApplication,
		arg.Name,
		arg.Description,
		arg.DeveloperID,
		arg.Category,
		arg.Price,
		arg.Size,
		arg.MinAndroidVersion,
		arg.CurrentVersion,
		arg.Tags,
		arg.Screenshots,
		arg.StorageUrl,
	)
	var i CreateApplicationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DeveloperID,
		&i.Category,
		&i.Price,
		&i.Size,
		&i.MinAndroidVersion,
		&i.CurrentVersion,
		&i.Tags,
		&i.Screenshots,
		&i.StorageUrl,
		&i.Rating,
		&i.Downloads,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteApplication = `-- name: DeleteApplication :exec
DELETE FROM applications
WHERE id = $1
`

func (q *Queries) DeleteApplication(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteApplication, id)
	return err
}

const GetApplication = `-- name: GetApplication :one
SELECT 
    id, name, description, developer_id, category, price, size,
    min_android_version, current_version, tags, screenshots, storage_url,
    rating, downloads, created_at, updated_at
FROM applications
WHERE id = $1 LIMIT 1
`

type GetApplicationRow struct {
	ID                pgtype.UUID        `db:"id" json:"id"`
	Name              string             `db:"name" json:"name"`
	Description       pgtype.Text        `db:"description" json:"description"`
	DeveloperID       pgtype.UUID        `db:"developer_id" json:"developer_id"`
	Category          string             `db:"category" json:"category"`
	Price             pgtype.Numeric     `db:"price" json:"price"`
	Size              int64              `db:"size" json:"size"`
	MinAndroidVersion string             `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string             `db:"current_version" json:"current_version"`
	Tags              []string           `db:"tags" json:"tags"`
	Screenshots       []string           `db:"screenshots" json:"screenshots"`
	StorageUrl        string             `db:"storage_url" json:"storage_url"`
	Rating            pgtype.Numeric     `db:"rating" json:"rating"`
	Downloads         int32              `db:"downloads" json:"downloads"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetApplication(ctx context.Context, id pgtype.UUID) (*GetApplicationRow, error) {
	row := q.db.QueryRow(ctx, GetApplication, id)
	var i GetApplicationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DeveloperID,
		&i.Category,
		&i.Price,
		&i.Size,
		&i.MinAndroidVersion,
		&i.CurrentVersion,
		&i.Tags,
		&i.Screenshots,
		&i.StorageUrl,
		&i.Rating,
		&i.Downloads,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const IncrementDownloads = `-- name: IncrementDownloads :one
UPDATE applications
SET downloads = downloads + 1
WHERE id = $1
RETURNING 
    id, name, description, developer_id, category, price, size,
    min_android_version, current_version, tags, screenshots, storage_url,
    rating, downloads, created_at, updated_at
`

type IncrementDownloadsRow struct {
	ID                pgtype.UUID        `db:"id" json:"id"`
	Name              string             `db:"name" json:"name"`
	Description       pgtype.Text        `db:"description" json:"description"`
	DeveloperID       pgtype.UUID        `db:"developer_id" json:"developer_id"`
	Category          string             `db:"category" json:"category"`
	Price             pgtype.Numeric     `db:"price" json:"price"`
	Size              int64              `db:"size" json:"size"`
	MinAndroidVersion string             `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string             `db:"current_version" json:"current_version"`
	Tags              []string           `db:"tags" json:"tags"`
	Screenshots       []string           `db:"screenshots" json:"screenshots"`
	StorageUrl        string             `db:"storage_url" json:"storage_url"`
	Rating            pgtype.Numeric     `db:"rating" json:"rating"`
	Downloads         int32              `db:"downloads" json:"downloads"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) IncrementDownloads(ctx context.Context, id pgtype.UUID) (*IncrementDownloadsRow, error) {
	row := q.db.QueryRow(ctx, IncrementDownloads, id)
	var i IncrementDownloadsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DeveloperID,
		&i.Category,
		&i.Price,
		&i.Size,
		&i.MinAndroidVersion,
		&i.CurrentVersion,
		&i.Tags,
		&i.Screenshots,
		&i.StorageUrl,
		&i.Rating,
		&i.Downloads,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListApplications = `-- name: ListApplications :many
SELECT 
    id, name, description, developer_id, category, price, size,
    min_android_version, current_version, tags, screenshots, storage_url,
    rating, downloads, created_at, updated_at
FROM applications
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListApplicationsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListApplicationsRow struct {
	ID                pgtype.UUID        `db:"id" json:"id"`
	Name              string             `db:"name" json:"name"`
	Description       pgtype.Text        `db:"description" json:"description"`
	DeveloperID       pgtype.UUID        `db:"developer_id" json:"developer_id"`
	Category          string             `db:"category" json:"category"`
	Price             pgtype.Numeric     `db:"price" json:"price"`
	Size              int64              `db:"size" json:"size"`
	MinAndroidVersion string             `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string             `db:"current_version" json:"current_version"`
	Tags              []string           `db:"tags" json:"tags"`
	Screenshots       []string           `db:"screenshots" json:"screenshots"`
	StorageUrl        string             `db:"storage_url" json:"storage_url"`
	Rating            pgtype.Numeric     `db:"rating" json:"rating"`
	Downloads         int32              `db:"downloads" json:"downloads"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListApplications(ctx context.Context, arg *ListApplicationsParams) ([]*ListApplicationsRow, error) {
	rows, err := q.db.Query(ctx, ListApplications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListApplicationsRow{}
	for rows.Next() {
		var i ListApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DeveloperID,
			&i.Category,
			&i.Price,
			&i.Size,
			&i.MinAndroidVersion,
			&i.CurrentVersion,
			&i.Tags,
			&i.Screenshots,
			&i.StorageUrl,
			&i.Rating,
			&i.Downloads,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCategories = `-- name: ListCategories :many
SELECT id, name, description, created_at, updated_at
FROM categories
ORDER BY name ASC
LIMIT $1 OFFSET $2
`

type ListCategoriesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListCategories(ctx context.Context, arg *ListCategoriesParams) ([]*Category, error) {
	rows, err := q.db.Query(ctx, ListCategories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchApplications = `-- name: SearchApplications :many
SELECT 
    id, name, description, developer_id, category, price, size,
    min_android_version, current_version, tags, screenshots, storage_url,
    rating, downloads, created_at, updated_at
FROM applications
WHERE
    CASE
        WHEN $3::text != '' THEN
            search_vector @@ plainto_tsquery('english', $3::text)
        ELSE true
    END
    AND CASE
        WHEN $4::text != '' THEN
            category = $4::text
        ELSE true
    END
    AND CASE
        WHEN $5::decimal >= 0 THEN
            price >= $5::decimal
        ELSE true
    END
    AND CASE
        WHEN $6::decimal >= 0 THEN
            price <= $6::decimal
        ELSE true
    END
    AND CASE
        WHEN $7::text != '' THEN
            min_android_version >= $7::text
        ELSE true
    END
    AND CASE
        WHEN array_length($8::text[], 1) > 0 THEN
            tags && $8::text[]
        ELSE true
    END
ORDER BY
    CASE
        WHEN $9::boolean = true THEN downloads
        ELSE NULL
    END DESC NULLS LAST,
    CASE
        WHEN $10::boolean = true THEN rating
        ELSE NULL
    END DESC NULLS LAST,
    created_at DESC
LIMIT $1 OFFSET $2
`

type SearchApplicationsParams struct {
	Limit             int32          `db:"limit" json:"limit"`
	Offset            int32          `db:"offset" json:"offset"`
	Query             string         `db:"query" json:"query"`
	Category          string         `db:"category" json:"category"`
	MinPrice          pgtype.Numeric `db:"min_price" json:"min_price"`
	MaxPrice          pgtype.Numeric `db:"max_price" json:"max_price"`
	MinAndroidVersion string         `db:"min_android_version" json:"min_android_version"`
	Tags              []string       `db:"tags" json:"tags"`
	SortByDownloads   bool           `db:"sort_by_downloads" json:"sort_by_downloads"`
	SortByRating      bool           `db:"sort_by_rating" json:"sort_by_rating"`
}

type SearchApplicationsRow struct {
	ID                pgtype.UUID        `db:"id" json:"id"`
	Name              string             `db:"name" json:"name"`
	Description       pgtype.Text        `db:"description" json:"description"`
	DeveloperID       pgtype.UUID        `db:"developer_id" json:"developer_id"`
	Category          string             `db:"category" json:"category"`
	Price             pgtype.Numeric     `db:"price" json:"price"`
	Size              int64              `db:"size" json:"size"`
	MinAndroidVersion string             `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string             `db:"current_version" json:"current_version"`
	Tags              []string           `db:"tags" json:"tags"`
	Screenshots       []string           `db:"screenshots" json:"screenshots"`
	StorageUrl        string             `db:"storage_url" json:"storage_url"`
	Rating            pgtype.Numeric     `db:"rating" json:"rating"`
	Downloads         int32              `db:"downloads" json:"downloads"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) SearchApplications(ctx context.Context, arg *SearchApplicationsParams) ([]*SearchApplicationsRow, error) {
	rows, err := q.db.Query(ctx, SearchApplications,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.Category,
		arg.MinPrice,
		arg.MaxPrice,
		arg.MinAndroidVersion,
		arg.Tags,
		arg.SortByDownloads,
		arg.SortByRating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchApplicationsRow{}
	for rows.Next() {
		var i SearchApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DeveloperID,
			&i.Category,
			&i.Price,
			&i.Size,
			&i.MinAndroidVersion,
			&i.CurrentVersion,
			&i.Tags,
			&i.Screenshots,
			&i.StorageUrl,
			&i.Rating,
			&i.Downloads,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateApplication = `-- name: UpdateApplication :one
UPDATE applications
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    category = COALESCE($3, category),
    price = COALESCE($4, price),
    min_android_version = COALESCE($5, min_android_version),
    current_version = COALESCE($6, current_version),
    tags = COALESCE($7, tags),
    screenshots = COALESCE($8, screenshots),
    storage_url = COALESCE($9, storage_url),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $10
RETURNING 
    id, name, description, developer_id, category, price, size,
    min_android_version, current_version, tags, screenshots, storage_url,
    rating, downloads, created_at, updated_at
`

type UpdateApplicationParams struct {
	Name              pgtype.Text    `db:"name" json:"name"`
	Description       pgtype.Text    `db:"description" json:"description"`
	Category          pgtype.Text    `db:"category" json:"category"`
	Price             pgtype.Numeric `db:"price" json:"price"`
	MinAndroidVersion pgtype.Text    `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    pgtype.Text    `db:"current_version" json:"current_version"`
	Tags              []string       `db:"tags" json:"tags"`
	Screenshots       []string       `db:"screenshots" json:"screenshots"`
	StorageUrl        pgtype.Text    `db:"storage_url" json:"storage_url"`
	ID                pgtype.UUID    `db:"id" json:"id"`
}

type UpdateApplicationRow struct {
	ID                pgtype.UUID        `db:"id" json:"id"`
	Name              string             `db:"name" json:"name"`
	Description       pgtype.Text        `db:"description" json:"description"`
	DeveloperID       pgtype.UUID        `db:"developer_id" json:"developer_id"`
	Category          string             `db:"category" json:"category"`
	Price             pgtype.Numeric     `db:"price" json:"price"`
	Size              int64              `db:"size" json:"size"`
	MinAndroidVersion string             `db:"min_android_version" json:"min_android_version"`
	CurrentVersion    string             `db:"current_version" json:"current_version"`
	Tags              []string           `db:"tags" json:"tags"`
	Screenshots       []string           `db:"screenshots" json:"screenshots"`
	StorageUrl        string             `db:"storage_url" json:"storage_url"`
	Rating            pgtype.Numeric     `db:"rating" json:"rating"`
	Downloads         int32              `db:"downloads" json:"downloads"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateApplication(ctx context.Context, arg *UpdateApplicationParams) (*UpdateApplicationRow, error) {
	row := q.db.QueryRow(ctx, UpdateApplication,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.Price,
		arg.MinAndroidVersion,
		arg.CurrentVersion,
		arg.Tags,
		arg.Screenshots,
		arg.StorageUrl,
		arg.ID,
	)
	var i UpdateApplicationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DeveloperID,
		&i.Category,
		&i.Price,
		&i.Size,
		&i.MinAndroidVersion,
		&i.CurrentVersion,
		&i.Tags,
		&i.Screenshots,
		&i.StorageUrl,
		&i.Rating,
		&i.Downloads,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
